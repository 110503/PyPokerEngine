{
    "docs": [
        {
            "location": "/", 
            "text": "PyPokerEngine: poker AI development from today\n\n\nPyPokerEngine is a simple framework for Texas hold'em AI development.\n\n\nGetting Started - create our first AI\n\n\nTo get used to this library, we will create simple AI which always declares \nCALL\n action.\n\nTo create poker AI, what we do is following\n\n\n\n\nCreate PokerPlayer class which is subclass of \nPypokerEngine.players.BasePokerPlayer\n.\n\n\nImplement abstract methods which inherit from \nBasePokerPlayer\n class.\n\n\n\n\nHere is the code of our first AI.  \n\n\nfrom pypokerengine.players import BasePokerPlayer\n\nclass FishPlayer(BasePokerPlayer):  # Do not forget to make parent class as \nBasePokerPlayer\n\n\n    #  we define the logic to make an action through this method. (so this method would be the core of your AI)\n    def declare_action(self, valid_actions, hole_card, round_state):\n        # valid_actions format =\n [raise_action_info, call_action_info, fold_action_info]\n        call_action_info = valid_actions[1]\n        action, amount = call_action_info[\naction\n], call_action_info[\namount\n]\n        return action, amount   # action returned here is sent to the poker engine\n\n    def receive_game_start_message(self, game_info):\n        pass\n\n    def receive_round_start_message(self, round_count, hole_card, seats):\n        pass\n\n    def receive_street_start_message(self, street, round_state):\n        pass\n\n    def receive_game_update_message(self, action, round_state):\n        pass\n\n    def receive_round_result_message(self, winners, hand_info, round_state):\n        pass\n\n\n\n\nIf you are interested in what each callback method receives, See \nAI_CALLBACK_FORMAT.md\n.\n\n\nPlay AI vs AI poker game\n\n\nOk, let's play the poker game by using our first AI \nFishPlayer\n.\n\nTo start the game, what we need to do is following\n\n\n\n\nDefine game rule through \nConfig\n object (ex. start stack, blind amount, ante, blind_structures)\n\n\nRegister AI with \nConfig\n object.\n\n\nStart the game and get game result\n\n\n\n\nHere is the code to play poker for 10 round with our created \nFishPlayer\n.\n\n\nfrom pypokerengine.api.game import setup_config, start_poker\n\nconfig = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\nconfig.register_player(name=\np1\n, algorithm=FishPlayer())\nconfig.register_player(name=\np2\n, algorithm=FishPlayer())\nconfig.register_player(name=\np3\n, algorithm=FishPlayer())\ngame_result = start_poker(config, verbose=1)\n\n\n\n\nWe set \nverbose=1\n in \nstart_poker\n method, so simple game logs will be output after \nstart_poker\n call.\n\n\nStarted the round 1\nStreet \npreflop\n started. (community card = [])\n\np1\n declared \ncall:10\n\n\np2\n declared \ncall:10\n\n\np3\n declared \ncall:10\n\nStreet \nflop\n started. (community card = ['C4', 'C6', 'CA'])\n\np2\n declared \ncall:0\n\n\np3\n declared \ncall:0\n\n\np1\n declared \ncall:0\n\nStreet \nturn\n started. (community card = ['C4', 'C6', 'CA', 'D4'])\n\np2\n declared \ncall:0\n\n\np3\n declared \ncall:0\n\n\np1\n declared \ncall:0\n\nStreet \nriver\n started. (community card = ['C4', 'C6', 'CA', 'D4', 'H2'])\n\np2\n declared \ncall:0\n\n\np3\n declared \ncall:0\n\n\np1\n declared \ncall:0\n\n\n['p3']\n won the round 1 (stack = {'p2': 90, 'p3': 120, 'p1': 90})\nStarted the round 2\n...\n\n['p1']\n won the round 10 (stack = {'p2': 30, 'p3': 120, 'p1': 150})\n\n\n\n\nFinally, let's check the game result !!\n\n\n print game_result\n{\n  'rule': {'ante': 0, 'blind_structure': {}, 'max_round': 10, 'initial_stack': 100, 'small_blind_amount': 5},\n  'players': [\n    {'stack': 150, 'state': 'participating', 'name': 'p1', 'uuid': 'ijaukuognlkplasfspehcp'},\n    {'stack': 30, 'state': 'participating', 'name': 'p2', 'uuid': 'uadjzyetdwsaxzflrdsysj'},\n    {'stack': 120, 'state': 'participating', 'name': 'p3', 'uuid': 'tmnkoazoqitkzcreihrhao'}\n  ]\n}\n\n\n\n\nInstallation\n\n\nYou can install by pip.\n\n\npip install PyPokerEngine\n\n\n\n\nNext Steps\n\n\nTo develop more practical AI, these tutorials would be helpful.\n\n\n\n\nParticipate in the game\n: create player you can control from console\n\n\nEstimate strength of your hands\n: PyPokerEngine provides api to estimate card strength by MonteCarloSimulation.\n\n\nLearn how to use Emulator\n learn about emulator which provides you fine-grained control of the game.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#pypokerengine-poker-ai-development-from-today", 
            "text": "PyPokerEngine is a simple framework for Texas hold'em AI development.", 
            "title": "PyPokerEngine: poker AI development from today"
        }, 
        {
            "location": "/#getting-started-create-our-first-ai", 
            "text": "To get used to this library, we will create simple AI which always declares  CALL  action. \nTo create poker AI, what we do is following   Create PokerPlayer class which is subclass of  PypokerEngine.players.BasePokerPlayer .  Implement abstract methods which inherit from  BasePokerPlayer  class.   Here is the code of our first AI.    from pypokerengine.players import BasePokerPlayer\n\nclass FishPlayer(BasePokerPlayer):  # Do not forget to make parent class as  BasePokerPlayer \n\n    #  we define the logic to make an action through this method. (so this method would be the core of your AI)\n    def declare_action(self, valid_actions, hole_card, round_state):\n        # valid_actions format =  [raise_action_info, call_action_info, fold_action_info]\n        call_action_info = valid_actions[1]\n        action, amount = call_action_info[ action ], call_action_info[ amount ]\n        return action, amount   # action returned here is sent to the poker engine\n\n    def receive_game_start_message(self, game_info):\n        pass\n\n    def receive_round_start_message(self, round_count, hole_card, seats):\n        pass\n\n    def receive_street_start_message(self, street, round_state):\n        pass\n\n    def receive_game_update_message(self, action, round_state):\n        pass\n\n    def receive_round_result_message(self, winners, hand_info, round_state):\n        pass  If you are interested in what each callback method receives, See  AI_CALLBACK_FORMAT.md .", 
            "title": "Getting Started - create our first AI"
        }, 
        {
            "location": "/#play-ai-vs-ai-poker-game", 
            "text": "Ok, let's play the poker game by using our first AI  FishPlayer . \nTo start the game, what we need to do is following   Define game rule through  Config  object (ex. start stack, blind amount, ante, blind_structures)  Register AI with  Config  object.  Start the game and get game result   Here is the code to play poker for 10 round with our created  FishPlayer .  from pypokerengine.api.game import setup_config, start_poker\n\nconfig = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\nconfig.register_player(name= p1 , algorithm=FishPlayer())\nconfig.register_player(name= p2 , algorithm=FishPlayer())\nconfig.register_player(name= p3 , algorithm=FishPlayer())\ngame_result = start_poker(config, verbose=1)  We set  verbose=1  in  start_poker  method, so simple game logs will be output after  start_poker  call.  Started the round 1\nStreet  preflop  started. (community card = []) p1  declared  call:10  p2  declared  call:10  p3  declared  call:10 \nStreet  flop  started. (community card = ['C4', 'C6', 'CA']) p2  declared  call:0  p3  declared  call:0  p1  declared  call:0 \nStreet  turn  started. (community card = ['C4', 'C6', 'CA', 'D4']) p2  declared  call:0  p3  declared  call:0  p1  declared  call:0 \nStreet  river  started. (community card = ['C4', 'C6', 'CA', 'D4', 'H2']) p2  declared  call:0  p3  declared  call:0  p1  declared  call:0  ['p3']  won the round 1 (stack = {'p2': 90, 'p3': 120, 'p1': 90})\nStarted the round 2\n... ['p1']  won the round 10 (stack = {'p2': 30, 'p3': 120, 'p1': 150})  Finally, let's check the game result !!   print game_result\n{\n  'rule': {'ante': 0, 'blind_structure': {}, 'max_round': 10, 'initial_stack': 100, 'small_blind_amount': 5},\n  'players': [\n    {'stack': 150, 'state': 'participating', 'name': 'p1', 'uuid': 'ijaukuognlkplasfspehcp'},\n    {'stack': 30, 'state': 'participating', 'name': 'p2', 'uuid': 'uadjzyetdwsaxzflrdsysj'},\n    {'stack': 120, 'state': 'participating', 'name': 'p3', 'uuid': 'tmnkoazoqitkzcreihrhao'}\n  ]\n}", 
            "title": "Play AI vs AI poker game"
        }, 
        {
            "location": "/#installation", 
            "text": "You can install by pip.  pip install PyPokerEngine", 
            "title": "Installation"
        }, 
        {
            "location": "/#next-steps", 
            "text": "To develop more practical AI, these tutorials would be helpful.   Participate in the game : create player you can control from console  Estimate strength of your hands : PyPokerEngine provides api to estimate card strength by MonteCarloSimulation.  Learn how to use Emulator  learn about emulator which provides you fine-grained control of the game.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/tutorial/participate_in_the_game/", 
            "text": "Play poker with AI\n\n\nThe simple way to evaluate AI strength is \nplaying poker with AI\n.\n\nIn this tutorial, we will create \nConsolePlayer\n to participate in the game via console.  \n\n\nCreate ConsolePlayer\n\n\nwe create \nConsolePlayer\n in the same way as \ncreating our first AI\n.\n\n(Override \nBasePokerPlayer\n class and implement abstracted methods)\n\n\nThe requirements for \nConsolePlayer\n are\n\n\n\n\ndisplay game information on console in formatted way\n\n\naccept player's action from console and apply it on the game\n\n\n\n\nSo the implementation would be like this.\n\n(This code does not handle errors for simplicity.\nYou can check complete code from \nhere\n)\n\n\nimport pypokerengine.utils.visualize_utils as U\n\nclass ConsolePlayer(BasePokerPlayer):\n\n    def declare_action(self, valid_actions, hole_card, round_state):\n        print(U.visualize_declare_action(valid_actions, hole_card, round_state, self.uuid))\n        action, amount = self._receive_action_from_console(valid_actions)\n        return action, amount\n\n    def receive_game_start_message(self, game_info):\n        print(U.visualize_game_start(game_info, self.uuid))\n        self._wait_until_input()\n\n    def receive_round_start_message(self, round_count, hole_card, seats):\n        print(U.visualize_round_start(round_count, hole_card, seats, self.uuid))\n        self._wait_until_input()\n\n    def receive_street_start_message(self, street, round_state):\n        print(U.visualize_street_start(street, round_state, self.uuid))\n        self._wait_until_input()\n\n    def receive_game_update_message(self, new_action, round_state):\n        print(U.visualize_game_update(new_action, round_state, self.uuid))\n        self._wait_until_input()\n\n    def receive_round_result_message(self, winners, hand_info, round_state):\n        print(U.visualize_round_result(winners, hand_info, round_state, self.uuid))\n        self._wait_until_input()\n\n    def _wait_until_input(self):\n        raw_input(\nEnter some key to continue ...\n)\n\n    # FIXME: This code would be crash if receives invalid input.\n    #        So you should add error handling properly.\n    def _receive_action_from_console(self, valid_actions):\n        action = raw_input(\nEnter action to declare \n \n)\n        if action == 'fold': amount = 0\n        if action == 'call':  amount = valid_actions[1]['action']\n        if action == 'raise':  amount = int(raw_input(\nEnter raise amount \n \n))\n        return action, amount\n\n\n\n\nBeat Our First AI by Our Own Hands\n\n\nNow we are ready to play the game. Let's try to beat our first AI \nFishPlayer\n!!  \n\n\nfrom pypokerengine.api.game import setup_config, start_poker\n\nconfig = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\nconfig.register_player(name=\nfish_player\n, algorithm=FishPlayer())\nconfig.register_player(name=\nhuman_player\n, algorithm=ConsolePlayer())\ngame_result = start_poker(config, verbose=0)  # verbose=0 because game progress is visualized by ConsolePlayer\n\n\n\n\nGame informations would be displayed on console like below.\n\n\n-- Game start (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- rule --\n  - 2 players game\n  - 10 round\n  - start stack = 100\n  -        ante = 0\n  - small blind = 5\n======================================================================\nEnter some key to continue ... \nENTER\n\n\n-- Round 1 start (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- hole card --\n  - ['CA', 'D2']\n-- players information --\n  - 0 : fish_player (vhchlzkojrabhiomwdbpem) =\n state : participating, stack : 90\n  - 1 : human_player (qrnewmfzuyacjscxpfftgy) =\n state : participating, stack : 95\n======================================================================\nEnter some key to continue ... \nENTER\n\n\n-- New street start (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- street --\n  - preflop\n======================================================================\nEnter some key to continue ...\n\n\n\n\nGood! We have Ace in hole card ! Let's ALLIN !!\n\n\n-- Declare your action (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- valid actions --\n  - fold\n  - call: 10\n  - raise: [15, 100]\n-- hole card --\n  - ['CA', 'D2']\n-- round state --\n  - dealer btn : fish_player\n  - street : preflop\n  - community card : []\n  - pot : main = 15, side = []\n  - players information\n    - 0 : fish_player (vhchlzkojrabhiomwdbpem) =\n state : participating, stack : 90 \n= BB\n    - 1 : human_player (qrnewmfzuyacjscxpfftgy) =\n state : participating, stack : 95 \n= SB, CURRENT\n  - action histories\n    - preflop\n      - {'action': 'SMALLBLIND', 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 5, 'add_amount': 5}\n      - {'action': 'BIGBLIND', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 10, 'add_amount': 5}\n======================================================================\nEnter action to declare \n raise\nEnter raise amount \n 100\n\n\n\n\nFishPlayer declares CALL action as we expected !\n\n\n-- Game update (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- new action --\n  - fish_player (vhchlzkojrabhiomwdbpem) declared call: 100\n-- round state --\n  - dealer btn : fish_player\n  - street : preflop\n  - community card : []\n  - pot : main = 200, side = [{'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}, {'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}]\n  - players information\n    - 0 : fish_player (vhchlzkojrabhiomwdbpem) =\n state : allin, stack : 0 \n= BB, CURRENT\n    - 1 : human_player (qrnewmfzuyacjscxpfftgy) =\n state : allin, stack : 0 \n= SB\n  - action histories\n    - preflop\n      - {'action': 'SMALLBLIND', 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 5, 'add_amount': 5}\n      - {'action': 'BIGBLIND', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 10, 'add_amount': 5}\n      - {'add_amount': 90, 'paid': 95, 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 100, 'action': 'RAISE'}\n      - {'action': 'CALL', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 100, 'paid': 90}\n======================================================================\nEnter some key to continue ...\n\n\n\n\nRound result is ...\n\n\n-- Round result (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- winners --\n  - fish_player (vhchlzkojrabhiomwdbpem) =\n state : allin, stack : 200\n-- hand info --\n  - fish_player (vhchlzkojrabhiomwdbpem)\n    - hand =\n TWOPAIR (high=14, low=8)\n    - hole =\n [14, 8]\n  - human_player (qrnewmfzuyacjscxpfftgy)\n    - hand =\n TWOPAIR (high=14, low=2)\n    - hole =\n [14, 2]\n-- round state --\n  - dealer btn : fish_player\n  - street : showdown\n  - community card : ['H7', 'HA', 'S2', 'H8', 'D6']\n  - pot : main = 200, side = [{'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}, {'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}]\n  - players information\n    - 0 : fish_player (vhchlzkojrabhiomwdbpem) =\n state : allin, stack : 200 \n= BB\n    - 1 : human_player (qrnewmfzuyacjscxpfftgy) =\n state : allin, stack : 0 \n= SB\n  - action histories\n    - preflop\n      - {'action': 'SMALLBLIND', 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 5, 'add_amount': 5}\n      - {'action': 'BIGBLIND', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 10, 'add_amount': 5}\n      - {'add_amount': 90, 'paid': 95, 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 100, 'action': 'RAISE'}\n      - {'action': 'CALL', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 100, 'paid': 90}\n======================================================================\n\n\n\n\nOMG... FishPlayer also has Ace(the rank of Ace is 14) in his hole card...\n\n\nWe cannot beat FishPlayer.\n\nBut I think you can understand how to compete with your own AIs.", 
            "title": "Participate in the game"
        }, 
        {
            "location": "/tutorial/participate_in_the_game/#play-poker-with-ai", 
            "text": "The simple way to evaluate AI strength is  playing poker with AI . \nIn this tutorial, we will create  ConsolePlayer  to participate in the game via console.", 
            "title": "Play poker with AI"
        }, 
        {
            "location": "/tutorial/participate_in_the_game/#create-consoleplayer", 
            "text": "we create  ConsolePlayer  in the same way as  creating our first AI . \n(Override  BasePokerPlayer  class and implement abstracted methods)  The requirements for  ConsolePlayer  are   display game information on console in formatted way  accept player's action from console and apply it on the game   So the implementation would be like this. \n(This code does not handle errors for simplicity.\nYou can check complete code from  here )  import pypokerengine.utils.visualize_utils as U\n\nclass ConsolePlayer(BasePokerPlayer):\n\n    def declare_action(self, valid_actions, hole_card, round_state):\n        print(U.visualize_declare_action(valid_actions, hole_card, round_state, self.uuid))\n        action, amount = self._receive_action_from_console(valid_actions)\n        return action, amount\n\n    def receive_game_start_message(self, game_info):\n        print(U.visualize_game_start(game_info, self.uuid))\n        self._wait_until_input()\n\n    def receive_round_start_message(self, round_count, hole_card, seats):\n        print(U.visualize_round_start(round_count, hole_card, seats, self.uuid))\n        self._wait_until_input()\n\n    def receive_street_start_message(self, street, round_state):\n        print(U.visualize_street_start(street, round_state, self.uuid))\n        self._wait_until_input()\n\n    def receive_game_update_message(self, new_action, round_state):\n        print(U.visualize_game_update(new_action, round_state, self.uuid))\n        self._wait_until_input()\n\n    def receive_round_result_message(self, winners, hand_info, round_state):\n        print(U.visualize_round_result(winners, hand_info, round_state, self.uuid))\n        self._wait_until_input()\n\n    def _wait_until_input(self):\n        raw_input( Enter some key to continue ... )\n\n    # FIXME: This code would be crash if receives invalid input.\n    #        So you should add error handling properly.\n    def _receive_action_from_console(self, valid_actions):\n        action = raw_input( Enter action to declare    )\n        if action == 'fold': amount = 0\n        if action == 'call':  amount = valid_actions[1]['action']\n        if action == 'raise':  amount = int(raw_input( Enter raise amount    ))\n        return action, amount", 
            "title": "Create ConsolePlayer"
        }, 
        {
            "location": "/tutorial/participate_in_the_game/#beat-our-first-ai-by-our-own-hands", 
            "text": "Now we are ready to play the game. Let's try to beat our first AI  FishPlayer !!    from pypokerengine.api.game import setup_config, start_poker\n\nconfig = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\nconfig.register_player(name= fish_player , algorithm=FishPlayer())\nconfig.register_player(name= human_player , algorithm=ConsolePlayer())\ngame_result = start_poker(config, verbose=0)  # verbose=0 because game progress is visualized by ConsolePlayer  Game informations would be displayed on console like below.  -- Game start (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- rule --\n  - 2 players game\n  - 10 round\n  - start stack = 100\n  -        ante = 0\n  - small blind = 5\n======================================================================\nEnter some key to continue ...  ENTER \n\n-- Round 1 start (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- hole card --\n  - ['CA', 'D2']\n-- players information --\n  - 0 : fish_player (vhchlzkojrabhiomwdbpem) =  state : participating, stack : 90\n  - 1 : human_player (qrnewmfzuyacjscxpfftgy) =  state : participating, stack : 95\n======================================================================\nEnter some key to continue ...  ENTER \n\n-- New street start (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- street --\n  - preflop\n======================================================================\nEnter some key to continue ...  Good! We have Ace in hole card ! Let's ALLIN !!  -- Declare your action (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- valid actions --\n  - fold\n  - call: 10\n  - raise: [15, 100]\n-- hole card --\n  - ['CA', 'D2']\n-- round state --\n  - dealer btn : fish_player\n  - street : preflop\n  - community card : []\n  - pot : main = 15, side = []\n  - players information\n    - 0 : fish_player (vhchlzkojrabhiomwdbpem) =  state : participating, stack : 90  = BB\n    - 1 : human_player (qrnewmfzuyacjscxpfftgy) =  state : participating, stack : 95  = SB, CURRENT\n  - action histories\n    - preflop\n      - {'action': 'SMALLBLIND', 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 5, 'add_amount': 5}\n      - {'action': 'BIGBLIND', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 10, 'add_amount': 5}\n======================================================================\nEnter action to declare   raise\nEnter raise amount   100  FishPlayer declares CALL action as we expected !  -- Game update (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- new action --\n  - fish_player (vhchlzkojrabhiomwdbpem) declared call: 100\n-- round state --\n  - dealer btn : fish_player\n  - street : preflop\n  - community card : []\n  - pot : main = 200, side = [{'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}, {'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}]\n  - players information\n    - 0 : fish_player (vhchlzkojrabhiomwdbpem) =  state : allin, stack : 0  = BB, CURRENT\n    - 1 : human_player (qrnewmfzuyacjscxpfftgy) =  state : allin, stack : 0  = SB\n  - action histories\n    - preflop\n      - {'action': 'SMALLBLIND', 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 5, 'add_amount': 5}\n      - {'action': 'BIGBLIND', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 10, 'add_amount': 5}\n      - {'add_amount': 90, 'paid': 95, 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 100, 'action': 'RAISE'}\n      - {'action': 'CALL', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 100, 'paid': 90}\n======================================================================\nEnter some key to continue ...  Round result is ...  -- Round result (UUID = qrnewmfzuyacjscxpfftgy) --\n======================================================================\n-- winners --\n  - fish_player (vhchlzkojrabhiomwdbpem) =  state : allin, stack : 200\n-- hand info --\n  - fish_player (vhchlzkojrabhiomwdbpem)\n    - hand =  TWOPAIR (high=14, low=8)\n    - hole =  [14, 8]\n  - human_player (qrnewmfzuyacjscxpfftgy)\n    - hand =  TWOPAIR (high=14, low=2)\n    - hole =  [14, 2]\n-- round state --\n  - dealer btn : fish_player\n  - street : showdown\n  - community card : ['H7', 'HA', 'S2', 'H8', 'D6']\n  - pot : main = 200, side = [{'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}, {'amount': 0, 'eligibles': ['vhchlzkojrabhiomwdbpem', 'qrnewmfzuyacjscxpfftgy']}]\n  - players information\n    - 0 : fish_player (vhchlzkojrabhiomwdbpem) =  state : allin, stack : 200  = BB\n    - 1 : human_player (qrnewmfzuyacjscxpfftgy) =  state : allin, stack : 0  = SB\n  - action histories\n    - preflop\n      - {'action': 'SMALLBLIND', 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 5, 'add_amount': 5}\n      - {'action': 'BIGBLIND', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 10, 'add_amount': 5}\n      - {'add_amount': 90, 'paid': 95, 'player': 'human_player (uuid=qrnewmfzuyacjscxpfftgy)', 'amount': 100, 'action': 'RAISE'}\n      - {'action': 'CALL', 'player': 'fish_player (uuid=vhchlzkojrabhiomwdbpem)', 'amount': 100, 'paid': 90}\n======================================================================  OMG... FishPlayer also has Ace(the rank of Ace is 14) in his hole card...  We cannot beat FishPlayer. \nBut I think you can understand how to compete with your own AIs.", 
            "title": "Beat Our First AI by Our Own Hands"
        }, 
        {
            "location": "/tutorial/estimate_card_strength/", 
            "text": "How to Estimate Hand Strength\n\n\nThe hand strength is key factor to make a decision in poker.\n\nIf our hole card is ['H4', 'D7'] and community cards are ['D3', 'C5', 'C6'],\nwe would take agreessive action.\n\n\nWe can make an estimate of hand strength. But how to teach it to our AI?\n\nOne simple way is \nrunning lots of simulations and use average win rate as estimation\n.\n\n\nIn this tutorial, we will create \nHonestPlayer\n which declares CALL only if his hand is good.\n\n\nEstimate Hand Strength by simulation\n\n\nThe code to estimates win rate of hands in three players game would be like this.\n\n\nnb_simulation = 1000\nnb_player = 3\nhole_card = ['H4', 'D7']\ncommunity_card = ['D3', 'C5', 'C6']\n\ndef estimate_hand_strength(nb_simulation, nb_player, hole_card, community_card):\n    simulation_results = []\n    for i in range(nb_simulation):\n        opponents_cards = []\n        for j in range(nb_player-1):  # nb_opponents = nb_player - 1\n            opponents_cards.append(draw_cards_from_deck(num=2))\n        nb_need_community = 5 - len(community_card)\n        community_card.append(draw_cards_from_deck(num=nb_need_community))\n        result = observe_game_result(hole_card, community_card, opponents_cards)  # return 1 if win else 0\n        simulation_results.append(result)\n    average_win_rate = 1.0 * sum(simulation_results) / len(simulation_results)\n    return average_win_rate\n\n\n\n\nPyPokerEngine prepares this method for you as \npypokerengine.utils.card_utils.estimate_hole_card_win_rate\n.\n\nLet's use it !!\n\n\n from pypokerengine.utils.card_utils import gen_cards, estimate_hole_card_win_rate\n\n hole_card = gen_cards(['H4', 'D7'])\n\n community_card = gen_cards(['D3', 'C5', 'C6'])\n\n estimate_hole_card_win_rate(nb_simulation=1000, nb_player=3, hole_card=hole_card, community_card=community_card)\n0.825\n\n estimate_hole_card_win_rate(nb_simulation=1000, nb_player=3, hole_card=hole_card, community_card=community_card)\n0.838\n\n\n\n\nCreate HonestPlayer\n\n\nOk. Let's start \nHonestPlayer\n development.\n\nThe behavior of \nHonestPlayer\n is very simple (because he is honest).\n\n\n\n\ndeclare CALL if estimation of win_rate is grater than 1/nb_player\n\n\ndeclare FOLD othrewise\n\n\n\n\nThe code would be...\n\n\nfrom pypokerengine.players import BasePokerPlayer\nfrom pypokerengine.utils.card_utils import gen_cards, estimate_hole_card_win_rate\n\nNB_SIMULATION = 1000\n\nclass HonestPlayer(BasePokerPlayer):\n\n    def declare_action(self, valid_actions, hole_card, round_state):\n        community_card = round_state['community_card']\n        win_rate = estimate_hole_card_win_rate(\n                nb_simulation=NB_SIMULATION,\n                nb_player=self.nb_player,\n                hole_card=gen_cards(hole_card),\n                community_card=gen_cards(community_card)\n                )\n        if win_rate \n= 1.0 / self.nb_player:\n            action = valid_actions[1]  # fetch CALL action info\n        else:\n            action = valid_actions[0]  # fetch FOLD action info\n        return action['action'], action['amount']\n\n    def receive_game_start_message(self, game_info):\n        self.nb_player = game_info['player_num']\n\n    def receive_round_start_message(self, round_count, hole_card, seats):\n        pass\n\n    def receive_street_start_message(self, street, round_state):\n        pass\n\n    def receive_game_update_message(self, action, round_state):\n        pass\n\n    def receive_round_result_message(self, winners, hand_info, round_state):\n        pass\n\n\n\n\nLet's match \nHonestPlayer\n against \nFishPlayer\n.\n\n\n from pypokerengine.api.game import setup_config, start_poker\n\n config = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\n\n config.register_player(name=\nfish_player\n, algorithm=FishPlayer())\n\n config.register_player(name=\nhonest_player\n, algorithm=HonestPlayer())\n\n game_result = start_poker(config, verbose=1)\n\n for player_info in game_result[\nplayers\n]:\n...     print player_info\n...\n{'stack': 145, 'state': 'participating', 'name': 'fish_player', 'uuid': 'dziwzwkoqadaobrjxrfwog'}\n{'stack': 55, 'state': 'participating', 'name': 'honest_player', 'uuid': 'lcyzcxzbkuzvoyzlkommyt'}\n\n\n\n\nAs you see, \nHonestPlayer\n cannot win \nFishPlayer\n.\n\nBecause \nHonestPlayer\n always declares FOLD except when he has confident hands.\n\nThis strategy may sound good but he loses lots of money until he goes to SHOWDOWN.\n\n\nCreating practical poker AI is not easy unlike tick-tack-toe AI.\n\nIt would require some game specific heuristics or machine learning techniques.\n\nBut we believe that you can do it!!", 
            "title": "Estimate strength of your hands"
        }, 
        {
            "location": "/tutorial/estimate_card_strength/#how-to-estimate-hand-strength", 
            "text": "The hand strength is key factor to make a decision in poker. \nIf our hole card is ['H4', 'D7'] and community cards are ['D3', 'C5', 'C6'],\nwe would take agreessive action.  We can make an estimate of hand strength. But how to teach it to our AI? \nOne simple way is  running lots of simulations and use average win rate as estimation .  In this tutorial, we will create  HonestPlayer  which declares CALL only if his hand is good.", 
            "title": "How to Estimate Hand Strength"
        }, 
        {
            "location": "/tutorial/estimate_card_strength/#estimate-hand-strength-by-simulation", 
            "text": "The code to estimates win rate of hands in three players game would be like this.  nb_simulation = 1000\nnb_player = 3\nhole_card = ['H4', 'D7']\ncommunity_card = ['D3', 'C5', 'C6']\n\ndef estimate_hand_strength(nb_simulation, nb_player, hole_card, community_card):\n    simulation_results = []\n    for i in range(nb_simulation):\n        opponents_cards = []\n        for j in range(nb_player-1):  # nb_opponents = nb_player - 1\n            opponents_cards.append(draw_cards_from_deck(num=2))\n        nb_need_community = 5 - len(community_card)\n        community_card.append(draw_cards_from_deck(num=nb_need_community))\n        result = observe_game_result(hole_card, community_card, opponents_cards)  # return 1 if win else 0\n        simulation_results.append(result)\n    average_win_rate = 1.0 * sum(simulation_results) / len(simulation_results)\n    return average_win_rate  PyPokerEngine prepares this method for you as  pypokerengine.utils.card_utils.estimate_hole_card_win_rate . \nLet's use it !!   from pypokerengine.utils.card_utils import gen_cards, estimate_hole_card_win_rate  hole_card = gen_cards(['H4', 'D7'])  community_card = gen_cards(['D3', 'C5', 'C6'])  estimate_hole_card_win_rate(nb_simulation=1000, nb_player=3, hole_card=hole_card, community_card=community_card)\n0.825  estimate_hole_card_win_rate(nb_simulation=1000, nb_player=3, hole_card=hole_card, community_card=community_card)\n0.838", 
            "title": "Estimate Hand Strength by simulation"
        }, 
        {
            "location": "/tutorial/estimate_card_strength/#create-honestplayer", 
            "text": "Ok. Let's start  HonestPlayer  development. \nThe behavior of  HonestPlayer  is very simple (because he is honest).   declare CALL if estimation of win_rate is grater than 1/nb_player  declare FOLD othrewise   The code would be...  from pypokerengine.players import BasePokerPlayer\nfrom pypokerengine.utils.card_utils import gen_cards, estimate_hole_card_win_rate\n\nNB_SIMULATION = 1000\n\nclass HonestPlayer(BasePokerPlayer):\n\n    def declare_action(self, valid_actions, hole_card, round_state):\n        community_card = round_state['community_card']\n        win_rate = estimate_hole_card_win_rate(\n                nb_simulation=NB_SIMULATION,\n                nb_player=self.nb_player,\n                hole_card=gen_cards(hole_card),\n                community_card=gen_cards(community_card)\n                )\n        if win_rate  = 1.0 / self.nb_player:\n            action = valid_actions[1]  # fetch CALL action info\n        else:\n            action = valid_actions[0]  # fetch FOLD action info\n        return action['action'], action['amount']\n\n    def receive_game_start_message(self, game_info):\n        self.nb_player = game_info['player_num']\n\n    def receive_round_start_message(self, round_count, hole_card, seats):\n        pass\n\n    def receive_street_start_message(self, street, round_state):\n        pass\n\n    def receive_game_update_message(self, action, round_state):\n        pass\n\n    def receive_round_result_message(self, winners, hand_info, round_state):\n        pass  Let's match  HonestPlayer  against  FishPlayer .   from pypokerengine.api.game import setup_config, start_poker  config = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)  config.register_player(name= fish_player , algorithm=FishPlayer())  config.register_player(name= honest_player , algorithm=HonestPlayer())  game_result = start_poker(config, verbose=1)  for player_info in game_result[ players ]:\n...     print player_info\n...\n{'stack': 145, 'state': 'participating', 'name': 'fish_player', 'uuid': 'dziwzwkoqadaobrjxrfwog'}\n{'stack': 55, 'state': 'participating', 'name': 'honest_player', 'uuid': 'lcyzcxzbkuzvoyzlkommyt'}  As you see,  HonestPlayer  cannot win  FishPlayer . \nBecause  HonestPlayer  always declares FOLD except when he has confident hands. \nThis strategy may sound good but he loses lots of money until he goes to SHOWDOWN.  Creating practical poker AI is not easy unlike tick-tack-toe AI. \nIt would require some game specific heuristics or machine learning techniques. \nBut we believe that you can do it!!", 
            "title": "Create HonestPlayer"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/", 
            "text": "Getting fine-grained control of the game\n\n\nYou can run the game and get game result like this.\n\n\n from pypokerengine.api.game import setup_config, start_poker\n\n config = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\n\n config.register_player(name=\nfish_player\n, algorithm=FishPlayer())\n\n config.register_player(name=\nhonest_player\n, algorithm=HonestPlayer())\n\n game_result = start_poker(config, verbose=1)\n\n\n\n\nBut sometimes you want more fine-grained control of the game like stepwise simulation from current state.\n\nPyPokerEngine provides \nEmulator\n class whcih enables you to simulate the game as you want.  \n\n\nIn this tutorial, we will create \nEmulatorPlayer\n to understand how to use \nEmulator\n class.\n\n(\nEmulatorPlayer\n would not be practical AI but good example to learn about \nEmulator\n)\n\n\nHow to use Emulator\n\n\nRegister game settings on Emulator\n\n\nFirst we need to setup \nEmulator\n object with game settings like number of player.\n\n\nfrom pypokerengine.api.emulator import Emulator\n\nemulator = Emulator()\nemulator.set_game_rule(nb_player=2, max_round=10, sb_amount=5, ante_amount=0)\n\n\n\n\nRegister player's model on Emulator\n\n\nTo simulate the game, we need to create \nmodel of player\n.\n\n\nmodel of player\n defines how player behaves in the game.  \n\n\nCreating \nmodel of player\n is completely same step to create a player.\n\n(Override \nBasePokerPlayer\n class and implement its abstracted methods.)\n\n\nHere is the very simple model which always declares same action.  \n\n\nclass OneActionModel(BasePokerPlayer):\n\n    FOLD, CALL, MIN_RAISE, MAX_RAISE = 0, 1, 2, 3\n\n    def set_action(self, action):\n        self.action = action\n\n    def declare_action(self, valid_actions, hole_card, round_state):\n        if self.FOLD == self.action:\n            return valid_actions[0]['action'], valid_actions[0]['amount']\n        elif self.CALL == self.action:\n            return valid_actions[1]['action'], valid_actions[1]['amount']\n        elif self.MIN_RAISE == self.action:\n            return valid_actions[2]['action'], valid_actions[2]['amount']['min']\n        elif self.MAX_RAISE == self.action:\n            return valid_actions[2]['action'], valid_actions[2]['amount']['max']\n        else:\n            raise Exception(\nInvalid action [ %s ] is set\n % self.action)\n\n\n\n\nNext thing to do is register our model with emulator by \nemulator.register_player\n method.\n\nIn the simulation, \nEmulator\n calls \nplayer_model.declare_action\n and apply returned action\nto the simulation game.\n\n\np1_uuid = # uuid of player1. you would get this information from game_info object\np1_model = # setup model of player1\nemulator.register_player(uuid1, p1_model)\n\n\n\n\nSet up game state object\n\n\nBefore start simulation, we need to setup the \ngame_state\n object\nwhich represents the start point of the simulation.\n\nYou can setup \ngame_state\n object from \nround_state\n object like this.\n\n(You receive \nround_state\n object in callback method of \nBasePokerPlayer\n like \ndeclare_action\n.)\n\n\nfrom pypokerengine.utils.game_state_utils import\\\n        restore_game_state, attach_hole_card, attach_hole_card_from_deck\n\ndef setup_game_state(round_state, my_hole_card):\n    game_state = restore_game_state(round_state)\n    for player_info in round_state['seats']:\n        if uuid == self.uuid:\n            # Hole card of my player should be fixed. Because we know it.\n            game_state = attach_hole_card(game_state, uuid, my_hole_card)\n        else:\n            # We don't know hole card of opponents. So attach them at random from deck.\n            game_state = attach_hole_card_from_deck(game_state, uuid)\n\n\n\n\nround_state\n object represents public information of the game.\n\nThis means that it does not include information about hole card of each player.\n\nSo we need to restore that information on \ngame_state\n object.\n\n\nStart simulation and get updated game state object\n\n\nOk, everything is ready. Now you can progress or stop the game as you want by these methods.\n\n\n\n\nemulator.apply_action(game_state, action, bet_amount)\n\n\nUse this method if you want to progress the game step-by-step.\n\n\n\n\n\n\nemulator.run_until_round_finish(game_state)\n\n\nUse this method if you want to progress the game round-by-round.\n\n\n\n\n\n\nemulator.run_until_game_finish(game_state)\n\n\nUse this method if you want to see the final result of the simulation.\n\n\n\n\n\n\n\n\nEach method returns updated game state and events objects.\n\n(events object contains information of what happend during simulation like \"player1 declared call\", \"street is updated to FLOP\")  \n\n\n emulator.set_game_rule(nb_player, max_round=10, sb_amount=5, ante_amount=0)\n\n next_turn_state, events = emulator.apply_action(current_state, 'call', 10)\n\n round_finish_state, events = emulator.run_until_round_finish(current_state)\n\n game_finish_state, events = emulator.run_until_game_finish(current_state)\n\n\n\n current_state['round_count'], current_state['street'], current_state['next_player']\n(1, 0, 0)  # street_flg == 0 means PREFLOP\n\n next_turn_state['round_count'], next_turn_state['street'], next_turn_state['next_player']\n(1, 0, 1)\n\n round_finish_state['round_count'], round_finish_state['street'], round_finish_state['next_player']\n(1, 5, 0)  # street_flg == 5 means SHOWDOWN\n\n game_finish_state['round_count'], game_finish_state['street'], game_finish_state['next_player']\n(10, 5, 0)  # simulation is finished at 10 round because we set max_round=10\n\n\n\n\nFor more detail about \nEmulator\n or game_state, events objects,\n\nplease checkout \nEmulator documentation\n.\n\n\nCreate EmulatorPlayer\n\n\nTo sum up this tutorial, we will create sample AI \nEmulatorPlayer\n which uses \nEmulator\n to make a decision.  \n\n\nTo get accurate simulation result, fine-tuned player modeling is necessary.\n\nBut in this tutorial, we will match \nEmulatorPlayer\n against only \nFishPlayer\n.\n\nSo we use \nFishPlayer\n itself as model of opponent player.\n\n\nThe decision logic of \nEmulatorPlayer\n is like this.\n\n\n\n\nfix action to evaluate (FOLD, CALL, MIN_RAISE or MAX_RAISE)\n\n\nkeep declaring fixed action in the simulation until current round finishes\n\n\nremember the stack of EmulatorPlayer when simulation finished\n\n\nafter tried all actions, choose one which leads highest stack after the simulation\n\n\n\n\nThe implementation would be like this.\n\n\ntry_actions = [FOLD, CALL, MIN_RAISE, MAX_RAISE]\naction_score = [0, 0, 0, 0]\n\nfor try_action in try_actions:\n    # my_model \n- setup my model to declare \ntry_action\n anytime\n    simulation_results = []\n    for i in range(NB_SIMULATION):\n        # updated_state \n- run the simulation until current round finishes\n        # result \n- fetch stack of EmulatorPlayer in the updated_state\n        simulation_results.append(result)\n    # action_score \n- average simulation_results\n\n# best_action \n- choose action which gets highest action_score\nreturn best_action\n\n\n\n\nWe don't explaing implementation detail here.\n\nPlease check out complete implementation of \nEmulatorPlayer\n from \nhere\n.\n\n\nLet's match the \nEmulatorPlayer\n against our first AI \nFishPlayer\n.\n\n\n from pypokerengine.api.game import setup_config, start_poker\n\n config = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)\n\n config.register_player(name=\nfish_player\n, algorithm=FishPlayer())\n\n config.register_player(name=\nemulator_player\n, algorithm=EmulatorPlayer())\n\n game_result = start_poker(config, verbose=1)\nStarted the round 1\nStreet \npreflop\n started. (community card = [])\n[debug_info] --\n hole_card of emulator player is ['S6', 'H6']\n[debug_info] --\n average stack after simulation when declares FOLD : 95.0\n[debug_info] --\n average stack after simulation when declares CALL : 104.09\n[debug_info] --\n average stack after simulation when declares MIN_RAISE : 117.46\n[debug_info] --\n average stack after simulation when declares MAX_RAISE : 131.6\n\nemulator_player\n declared \nraise:100\n\n\nfish_player\n declared \ncall:100\n\nStreet \nflop\n started. (community card = ['HQ', 'D2', 'D8'])\nStreet \nturn\n started. (community card = ['HQ', 'D2', 'D8', 'S7'])\nStreet \nriver\n started. (community card = ['HQ', 'D2', 'D8', 'S7', 'SQ'])\n\n['emulator_player']\n won the round 1 (stack = {'emulator_player': 200, 'fish_player': 0})\n\n\n\n\nEmulatorPlayer\n choosed ALLIN with hole card ['S6', 'H6'] and beated \nFishPlayer\n!!\n\n(This result may look good. But \nEmulatorPlayer\n makes silly decision in most of the cases.)", 
            "title": "Simulate the game by emulator"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#getting-fine-grained-control-of-the-game", 
            "text": "You can run the game and get game result like this.   from pypokerengine.api.game import setup_config, start_poker  config = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)  config.register_player(name= fish_player , algorithm=FishPlayer())  config.register_player(name= honest_player , algorithm=HonestPlayer())  game_result = start_poker(config, verbose=1)  But sometimes you want more fine-grained control of the game like stepwise simulation from current state. \nPyPokerEngine provides  Emulator  class whcih enables you to simulate the game as you want.    In this tutorial, we will create  EmulatorPlayer  to understand how to use  Emulator  class. \n( EmulatorPlayer  would not be practical AI but good example to learn about  Emulator )", 
            "title": "Getting fine-grained control of the game"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#how-to-use-emulator", 
            "text": "", 
            "title": "How to use Emulator"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#register-game-settings-on-emulator", 
            "text": "First we need to setup  Emulator  object with game settings like number of player.  from pypokerengine.api.emulator import Emulator\n\nemulator = Emulator()\nemulator.set_game_rule(nb_player=2, max_round=10, sb_amount=5, ante_amount=0)", 
            "title": "Register game settings on Emulator"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#register-players-model-on-emulator", 
            "text": "To simulate the game, we need to create  model of player .  model of player  defines how player behaves in the game.    Creating  model of player  is completely same step to create a player. \n(Override  BasePokerPlayer  class and implement its abstracted methods.)  Here is the very simple model which always declares same action.    class OneActionModel(BasePokerPlayer):\n\n    FOLD, CALL, MIN_RAISE, MAX_RAISE = 0, 1, 2, 3\n\n    def set_action(self, action):\n        self.action = action\n\n    def declare_action(self, valid_actions, hole_card, round_state):\n        if self.FOLD == self.action:\n            return valid_actions[0]['action'], valid_actions[0]['amount']\n        elif self.CALL == self.action:\n            return valid_actions[1]['action'], valid_actions[1]['amount']\n        elif self.MIN_RAISE == self.action:\n            return valid_actions[2]['action'], valid_actions[2]['amount']['min']\n        elif self.MAX_RAISE == self.action:\n            return valid_actions[2]['action'], valid_actions[2]['amount']['max']\n        else:\n            raise Exception( Invalid action [ %s ] is set  % self.action)  Next thing to do is register our model with emulator by  emulator.register_player  method. \nIn the simulation,  Emulator  calls  player_model.declare_action  and apply returned action\nto the simulation game.  p1_uuid = # uuid of player1. you would get this information from game_info object\np1_model = # setup model of player1\nemulator.register_player(uuid1, p1_model)", 
            "title": "Register player's model on Emulator"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#set-up-game-state-object", 
            "text": "Before start simulation, we need to setup the  game_state  object\nwhich represents the start point of the simulation. \nYou can setup  game_state  object from  round_state  object like this. \n(You receive  round_state  object in callback method of  BasePokerPlayer  like  declare_action .)  from pypokerengine.utils.game_state_utils import\\\n        restore_game_state, attach_hole_card, attach_hole_card_from_deck\n\ndef setup_game_state(round_state, my_hole_card):\n    game_state = restore_game_state(round_state)\n    for player_info in round_state['seats']:\n        if uuid == self.uuid:\n            # Hole card of my player should be fixed. Because we know it.\n            game_state = attach_hole_card(game_state, uuid, my_hole_card)\n        else:\n            # We don't know hole card of opponents. So attach them at random from deck.\n            game_state = attach_hole_card_from_deck(game_state, uuid)  round_state  object represents public information of the game. \nThis means that it does not include information about hole card of each player. \nSo we need to restore that information on  game_state  object.", 
            "title": "Set up game state object"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#start-simulation-and-get-updated-game-state-object", 
            "text": "Ok, everything is ready. Now you can progress or stop the game as you want by these methods.   emulator.apply_action(game_state, action, bet_amount)  Use this method if you want to progress the game step-by-step.    emulator.run_until_round_finish(game_state)  Use this method if you want to progress the game round-by-round.    emulator.run_until_game_finish(game_state)  Use this method if you want to see the final result of the simulation.     Each method returns updated game state and events objects. \n(events object contains information of what happend during simulation like \"player1 declared call\", \"street is updated to FLOP\")     emulator.set_game_rule(nb_player, max_round=10, sb_amount=5, ante_amount=0)  next_turn_state, events = emulator.apply_action(current_state, 'call', 10)  round_finish_state, events = emulator.run_until_round_finish(current_state)  game_finish_state, events = emulator.run_until_game_finish(current_state)   current_state['round_count'], current_state['street'], current_state['next_player']\n(1, 0, 0)  # street_flg == 0 means PREFLOP  next_turn_state['round_count'], next_turn_state['street'], next_turn_state['next_player']\n(1, 0, 1)  round_finish_state['round_count'], round_finish_state['street'], round_finish_state['next_player']\n(1, 5, 0)  # street_flg == 5 means SHOWDOWN  game_finish_state['round_count'], game_finish_state['street'], game_finish_state['next_player']\n(10, 5, 0)  # simulation is finished at 10 round because we set max_round=10  For more detail about  Emulator  or game_state, events objects, \nplease checkout  Emulator documentation .", 
            "title": "Start simulation and get updated game state object"
        }, 
        {
            "location": "/tutorial/simulate_the_game_by_emulator/#create-emulatorplayer", 
            "text": "To sum up this tutorial, we will create sample AI  EmulatorPlayer  which uses  Emulator  to make a decision.    To get accurate simulation result, fine-tuned player modeling is necessary. \nBut in this tutorial, we will match  EmulatorPlayer  against only  FishPlayer . \nSo we use  FishPlayer  itself as model of opponent player.  The decision logic of  EmulatorPlayer  is like this.   fix action to evaluate (FOLD, CALL, MIN_RAISE or MAX_RAISE)  keep declaring fixed action in the simulation until current round finishes  remember the stack of EmulatorPlayer when simulation finished  after tried all actions, choose one which leads highest stack after the simulation   The implementation would be like this.  try_actions = [FOLD, CALL, MIN_RAISE, MAX_RAISE]\naction_score = [0, 0, 0, 0]\n\nfor try_action in try_actions:\n    # my_model  - setup my model to declare  try_action  anytime\n    simulation_results = []\n    for i in range(NB_SIMULATION):\n        # updated_state  - run the simulation until current round finishes\n        # result  - fetch stack of EmulatorPlayer in the updated_state\n        simulation_results.append(result)\n    # action_score  - average simulation_results\n\n# best_action  - choose action which gets highest action_score\nreturn best_action  We don't explaing implementation detail here. \nPlease check out complete implementation of  EmulatorPlayer  from  here .  Let's match the  EmulatorPlayer  against our first AI  FishPlayer .   from pypokerengine.api.game import setup_config, start_poker  config = setup_config(max_round=10, initial_stack=100, small_blind_amount=5)  config.register_player(name= fish_player , algorithm=FishPlayer())  config.register_player(name= emulator_player , algorithm=EmulatorPlayer())  game_result = start_poker(config, verbose=1)\nStarted the round 1\nStreet  preflop  started. (community card = [])\n[debug_info] --  hole_card of emulator player is ['S6', 'H6']\n[debug_info] --  average stack after simulation when declares FOLD : 95.0\n[debug_info] --  average stack after simulation when declares CALL : 104.09\n[debug_info] --  average stack after simulation when declares MIN_RAISE : 117.46\n[debug_info] --  average stack after simulation when declares MAX_RAISE : 131.6 emulator_player  declared  raise:100  fish_player  declared  call:100 \nStreet  flop  started. (community card = ['HQ', 'D2', 'D8'])\nStreet  turn  started. (community card = ['HQ', 'D2', 'D8', 'S7'])\nStreet  river  started. (community card = ['HQ', 'D2', 'D8', 'S7', 'SQ']) ['emulator_player']  won the round 1 (stack = {'emulator_player': 200, 'fish_player': 0})  EmulatorPlayer  choosed ALLIN with hole card ['S6', 'H6'] and beated  FishPlayer !! \n(This result may look good. But  EmulatorPlayer  makes silly decision in most of the cases.)", 
            "title": "Create EmulatorPlayer"
        }, 
        {
            "location": "/documentation/about_emulator/", 
            "text": "About Emulator\n\n\nEmulator\n gives you a fine-grained control of the game.\n\nThe common usage of \nEmulator\n would be\n\n\n\n\nSet game settings on emulator\n\n\nSetup GameState object which represents current game state\n\n\nRun simulation and get updated GameState object\n\n\n\n\nSo the code would be like this.\n\n\nfrom pypokerengine.api.emulator import Emulator\n\n# 1. Set game settings on emulator\nemulator = Emulator()\nemulator.set_game_rule(nb_player, final_round, sb_amount, ante)\nemulator.set_game_rule(player_num=3, max_round=10, small_blind_amount=5, ante_amount=1)\n\n# 2. Setup GameState object\nplayers_info = {\n    \nuuid-1\n: { \nname\n: \nplayer1\n, \nstack\n: 100 },\n    \nuuid-2\n: { \nname\n: \nplayer2\n, \nstack\n: 100 },\n    \nuuid-3\n: { \nname\n: \nplayer3\n, \nstack\n: 80 }\n}\ninitial_state = emulator.generate_initial_game_state(players_info)\ngame_state, events = emulator.start_new_round(initial_state)\n\n# 3. Run simulation and get updated GameState object\nupdated_state, events = emulator.apply_action(game_state, \ncall\n, 10)\n\n\n\n\nYou can run step-wise simulation with \nEmulator\n.\n\nThis feature would be useful when you use reinforcement learning method.\n\n\nGameState object\n\n\nWe need to prepare GameState object before run simulation.\n\nYou can setup GameState object in two ways.\n\n\n1. Generate clean game state with Emulator\n\n\nIf you want to generate clean (initial) GameState object,\nyou use \nemulator.generate_initial_game_state\n method.\n\n\nThis method requires players information of the game in below format.\n\n\nplayers_info = {\n  \nuuid_of_player1\n: { \nname\n: \nname_of_player1\n, \nstack\n: initial_stack_of_player1 },\n  \nuuid_of_player2\n: { \nname\n: \nname_of_player2\n, \nstack\n: initial_stack_of_player2 },\n  ...\n}\n\n\n\n\nSo you can get clean GameState object like this.\n\n\ninitial_game_state = emulator.generate_initial_game_state(players_info)\n\n\n\n\nPlease do not forget to start the round manually by \nemulator.start_new_round\n before run simulation\n\n(because clean GameState object represents the state before start the game).\n\n\n initial_game_state\n{'round_count': 0, 'next_player': None, 'street': 0, 'small_blind_amount': 5}, 'table': \npypokerengine.engine.table.Table instance at 0x10666cc68\n}\n\n game_state, events = emulator.start_new_round(initial_game_state)\n\n game_state\n{'round_count': 1, 'next_player': 0, 'street': 0, 'small_blind_amount': 5}, 'table': \npypokerengine.engine.table.Table instance at 0x1066bca28\n}\n\n\n\n\n2. Restore from \nround_state\n object\n\n\nround_state\n object is the public information of the game state \nwhich passed by callback methods of \nBasePokerPlayer\n like \ndeclare_action\n.\n\n\nIf you want to generate the GameState object which represents state of \nround_state\n,\nyou can use \ngame_state_utils.restore_game_state(round_state)\n.\n\n\nround_state\n object represents public information of the game.\nThis means that it does not include information about hole card of each player.\nSo you need to restore that information on GameState object by your hand.\n\n\nIf you set hole card at random, you can use below code.\n\n\nfrom pypokerengine.utils.game_state_utils import restore_game_state, attach_hole_card_from_deck\n\ngame_state = restore_game_state(round_state)\nfor player in game_state[\ntable\n].seats.players:\n    game_state = attach_hole_card_from_deck(game_state, player.uuid)\n\n\n\n\nIf you want to set specific card on specific player, the code would be...\n\n(below code sets holecard ['SA', 'DA'] on player which has uuid \"uuid-1\" and sets at random on others)\n\n\nfrom pypokerengine.utils.game_state_utils import restore_game_state, attach_hole_card_from_deck, attach_hole_card\nfrom pypokerengine.utils.card_utils import gen_cards\n\ngame_state = restore_game_state(round_state)\nfor player in game_state[\ntable\n].seats.players:\n    if player.uuid == \nuuid-1\n:\n        holecard = gen_cards(['SA', 'DA'])\n        game_state = attach_hole_card(game_state, player.uuid, hole_card)\n    else:\n      game_state = attach_hole_card_from_deck(game_state, player.uuid)\n\n\n\n\nEvent object\n\n\nWhen you run simulation bia \nEmulator\n, you receive updated GameState object and list of Event object.\n\nEvent object contains the information of event which happend during simulation.  \n\n\nFor example, Event objects of \nemulator.start_new_round\n would be ...\n\n\n game_state, events = emulator.start_new_round(initial_state)\n\n events\n[\n  {\n   'type': 'event_new_street',\n   'street': 'preflop',\n   'round_state': ...\n  },\n  {\n   'type': 'event_ask_player',\n   'uuid': 'uuid-1',\n   'valid_actions': [{'action': 'fold', 'amount': 0}, ...]\n  }\n]\n\n\n\n\nThere are 4 types of Event object.\n\n\n1. New Street Event\n\n\nThis event is contained if new street is started during simulation.  \n\n\n\n\ntype\n : \"event_new_street\"\n\n\nstreet\n : one of [\"preflop\", \"flop\", \"turn\", \"river\"]\n\n\nround_state\n: \nround_state\n object of when this event was occurred\n\n\n\n\n2. Ask Player Event\n\n\nThis event is contained when any player is asked his action.\n\n\n\n\ntype\n : \"event_ask_player\"\n\n\nuuid\n : uuid of player who asked the action\n\n\nvalid_actions\n: information of action which is valid in the situation.\n\n\nround_state\n: \nround_state\n object of when this event was occurred\n\n\n\n\n3. Round Finish Event\n\n\nThis event is contained when a round is finished.\n\n\n\n\ntype\n : \"event_round_finish\"\n\n\nwinners\n: information about the winner of round\n\n\nround_state\n: \nround_state\n object of when this event was occurred\n\n\n\n\n4. Game Finish Event\n\n\nThis event is contained when a game is finished.\n\n\n\n\ntype\n : \"event_game_finish\"\n\n\nplayers\n: information about each player like his stack, uuid, ...", 
            "title": "Emulator"
        }, 
        {
            "location": "/documentation/about_emulator/#about-emulator", 
            "text": "Emulator  gives you a fine-grained control of the game. \nThe common usage of  Emulator  would be   Set game settings on emulator  Setup GameState object which represents current game state  Run simulation and get updated GameState object   So the code would be like this.  from pypokerengine.api.emulator import Emulator\n\n# 1. Set game settings on emulator\nemulator = Emulator()\nemulator.set_game_rule(nb_player, final_round, sb_amount, ante)\nemulator.set_game_rule(player_num=3, max_round=10, small_blind_amount=5, ante_amount=1)\n\n# 2. Setup GameState object\nplayers_info = {\n     uuid-1 : {  name :  player1 ,  stack : 100 },\n     uuid-2 : {  name :  player2 ,  stack : 100 },\n     uuid-3 : {  name :  player3 ,  stack : 80 }\n}\ninitial_state = emulator.generate_initial_game_state(players_info)\ngame_state, events = emulator.start_new_round(initial_state)\n\n# 3. Run simulation and get updated GameState object\nupdated_state, events = emulator.apply_action(game_state,  call , 10)  You can run step-wise simulation with  Emulator . \nThis feature would be useful when you use reinforcement learning method.", 
            "title": "About Emulator"
        }, 
        {
            "location": "/documentation/about_emulator/#gamestate-object", 
            "text": "We need to prepare GameState object before run simulation. \nYou can setup GameState object in two ways.", 
            "title": "GameState object"
        }, 
        {
            "location": "/documentation/about_emulator/#1-generate-clean-game-state-with-emulator", 
            "text": "If you want to generate clean (initial) GameState object,\nyou use  emulator.generate_initial_game_state  method.  This method requires players information of the game in below format.  players_info = {\n   uuid_of_player1 : {  name :  name_of_player1 ,  stack : initial_stack_of_player1 },\n   uuid_of_player2 : {  name :  name_of_player2 ,  stack : initial_stack_of_player2 },\n  ...\n}  So you can get clean GameState object like this.  initial_game_state = emulator.generate_initial_game_state(players_info)  Please do not forget to start the round manually by  emulator.start_new_round  before run simulation \n(because clean GameState object represents the state before start the game).   initial_game_state\n{'round_count': 0, 'next_player': None, 'street': 0, 'small_blind_amount': 5}, 'table':  pypokerengine.engine.table.Table instance at 0x10666cc68 }  game_state, events = emulator.start_new_round(initial_game_state)  game_state\n{'round_count': 1, 'next_player': 0, 'street': 0, 'small_blind_amount': 5}, 'table':  pypokerengine.engine.table.Table instance at 0x1066bca28 }", 
            "title": "1. Generate clean game state with Emulator"
        }, 
        {
            "location": "/documentation/about_emulator/#2-restore-from-round_state-object", 
            "text": "round_state  object is the public information of the game state \nwhich passed by callback methods of  BasePokerPlayer  like  declare_action .  If you want to generate the GameState object which represents state of  round_state ,\nyou can use  game_state_utils.restore_game_state(round_state) .  round_state  object represents public information of the game.\nThis means that it does not include information about hole card of each player.\nSo you need to restore that information on GameState object by your hand.  If you set hole card at random, you can use below code.  from pypokerengine.utils.game_state_utils import restore_game_state, attach_hole_card_from_deck\n\ngame_state = restore_game_state(round_state)\nfor player in game_state[ table ].seats.players:\n    game_state = attach_hole_card_from_deck(game_state, player.uuid)  If you want to set specific card on specific player, the code would be... \n(below code sets holecard ['SA', 'DA'] on player which has uuid \"uuid-1\" and sets at random on others)  from pypokerengine.utils.game_state_utils import restore_game_state, attach_hole_card_from_deck, attach_hole_card\nfrom pypokerengine.utils.card_utils import gen_cards\n\ngame_state = restore_game_state(round_state)\nfor player in game_state[ table ].seats.players:\n    if player.uuid ==  uuid-1 :\n        holecard = gen_cards(['SA', 'DA'])\n        game_state = attach_hole_card(game_state, player.uuid, hole_card)\n    else:\n      game_state = attach_hole_card_from_deck(game_state, player.uuid)", 
            "title": "2. Restore from round_state object"
        }, 
        {
            "location": "/documentation/about_emulator/#event-object", 
            "text": "When you run simulation bia  Emulator , you receive updated GameState object and list of Event object. \nEvent object contains the information of event which happend during simulation.    For example, Event objects of  emulator.start_new_round  would be ...   game_state, events = emulator.start_new_round(initial_state)  events\n[\n  {\n   'type': 'event_new_street',\n   'street': 'preflop',\n   'round_state': ...\n  },\n  {\n   'type': 'event_ask_player',\n   'uuid': 'uuid-1',\n   'valid_actions': [{'action': 'fold', 'amount': 0}, ...]\n  }\n]  There are 4 types of Event object.", 
            "title": "Event object"
        }, 
        {
            "location": "/documentation/about_emulator/#1-new-street-event", 
            "text": "This event is contained if new street is started during simulation.     type  : \"event_new_street\"  street  : one of [\"preflop\", \"flop\", \"turn\", \"river\"]  round_state :  round_state  object of when this event was occurred", 
            "title": "1. New Street Event"
        }, 
        {
            "location": "/documentation/about_emulator/#2-ask-player-event", 
            "text": "This event is contained when any player is asked his action.   type  : \"event_ask_player\"  uuid  : uuid of player who asked the action  valid_actions : information of action which is valid in the situation.  round_state :  round_state  object of when this event was occurred", 
            "title": "2. Ask Player Event"
        }, 
        {
            "location": "/documentation/about_emulator/#3-round-finish-event", 
            "text": "This event is contained when a round is finished.   type  : \"event_round_finish\"  winners : information about the winner of round  round_state :  round_state  object of when this event was occurred", 
            "title": "3. Round Finish Event"
        }, 
        {
            "location": "/documentation/about_emulator/#4-game-finish-event", 
            "text": "This event is contained when a game is finished.   type  : \"event_game_finish\"  players : information about each player like his stack, uuid, ...", 
            "title": "4. Game Finish Event"
        }
    ]
}